# 리스트의 리스트

### 리스트의 리스트

계층에 티어를 하나 더 추가하겠습니다. 원래 예시에서 카드 데크를 가져와 여러 개의 데크가 포함된 상자를 작성하면 이제 상자에는 데크 리스트가 나타나고 각 데크에는 카드 리스트가 나타납니다. 이것은 리스트의 리스트입니다. 이 섹션의 내용을 바탕으로 유추해 보자면 아래의 이미지에는 동전 묶음 리스트가 포함되어 있고, 각 묶음에는 페니 리스트가 포함되어 있습니다.

![동전](../images/5-4/3/coins-521245\_640.jpg)

> 사진 출처: [Dori](https://commons.wikimedia.org/wiki/File:Stack\_of\_coins\_0214.jpg)

### 조회

리스트의 리스트에서 만들 수 있는 **조회**는 무엇일까요? 이러한 조회에서는 기존 특성을 확인합니다.

* 동전의 유형은 몇 가지입니까? 2\.
* 각 동전 유형의 값은 얼마입니까? $0.01 및 $0.25입니다.
* 쿼터는 무엇으로 만들어졌습니까? 75%의 구리와 25%의 니켈로 만들어졌습니다.
* 페니는 무엇으로 만들어졌습니까? 97.5%의 아연과 2.5%의 구리로 만들어졌습니다.

### 작업

리스트의 리스트에서 수행할 수 있는 **작업**은 무엇일까요? 작업을 수행하면 해당 작업을 기준으로 리스트의 리스트가 변경됩니다.

* 특정 쿼터 또는 페니의 스택을 선택합니다.
* 특정 쿼터 또는 페니를 선택합니다.
* 쿼터와 페니의 스택을 재정렬합니다.
* 스택을 한꺼번에 섞습니다.

다시 말씀드리지만, Dynamo에는 위에 나와 있는 각 작업과 유사한 노드가 있습니다. 우리는 물리적 객체가 아니라 추상 데이터로 작업하므로 데이터 계층을 위아래로 이동하는 방법을 제어하는 규칙 세트가 필요합니다.

리스트의 리스트를 다루는 경우에는 데이터가 겹쳐 있어 복잡하지만, 몇 가지 놀라운 파라메트릭 작업을 수행할 수 있습니다. 아래의 단원에서 기본 사항을 자세히 살펴보고 몇 가지 추가 작업에 대해 논의해 보겠습니다.

## 연습

### 하향식 계층

> 아래 링크를 클릭하여 예제 파일을 다운로드하십시오.
>
> 전체 예시 파일 리스트는 부록에서 확인할 수 있습니다.

{% file src="../datasets/5-4/3/Top-Down-Hierarchy.dyn" %}

이 섹션에서 배울 기본 개념은 **Dynamo에서는 리스트를 자체의 내부 객체로 취급한다**는 점입니다. 이 하향식 계층은 객체 지향적 프로그래밍을 염두에 두고 개발되었습니다. Dynamo에서는 **List.GetItemAtIndex**와 같은 명령으로 하위 요소를 선택하는 대신, 데이터 구조에서 주 리스트의 색인을 선택합니다. 그리고 해당 항목은 다른 리스트가 될 수 있습니다. 다음과 같이 예시 이미지로 자세히 살펴보겠습니다.

![하향식](../images/5-4/3/listsoflists-topdownhierachy.jpg)

> 1. **Code Block**을 사용하여 두 개의 범위(`0..2; 0..3;`)를 정의했습니다.
> 2. 이러한 범위는 레이싱이 _"외적"_ 으로 설정된 **Point.ByCoordinates** 노드에 연결됩니다. 이렇게 하면 점 그리드가 작성되고, 또한 리스트의 리스트가 출력으로 반환됩니다.
> 3. **Watch** 노드에서는 각 리스트에 4개의 항목이 있는 3개의 리스트를 제공합니다.
> 4. 색인이 0인 **List.GetItemAtIndex**를 사용하는 경우 Dynamo에서는 첫 번째 리스트와 해당 컨텐츠를 모두 선택합니다. 다른 프로그램에서는 데이터 구조에 있는 모든 리스트의 첫 번째 항목을 선택하겠지만, Dynamo에서는 데이터를 다룰 때 하향식 계층을 채택합니다.

### List.Flatten

> 아래 링크를 클릭하여 예제 파일을 다운로드하십시오.
>
> 전체 예시 파일 리스트는 부록에서 확인할 수 있습니다.

{% file src="../datasets/5-4/3/Flatten.dyn" %}

Flatten을 사용하면 데이터 구조에서 데이터의 모든 티어가 제거됩니다. 이는 데이터 계층이 작업에 필요하지 않은 경우에 유용하지만, 정보가 제거되므로 위험할 수 있습니다. 아래 예에서는 데이터 리스트를 단순화한 결과를 보여줍니다.

![연습](../images/5-4/3/listsoflists-flatten01.jpg)

> 1. 코드 줄을 하나 삽입하여 **Code Block**의 범위(`-250..-150..#4;`)를 정의합니다.
> 2. _code block_ 을 **Point.ByCoordinates** 노드의 _x_ 및 _y_ 입력에 플러깅하면 레이싱이 _"외적"_ 으로 설정되어 점의 그리드가 가져와집니다.
> 3. **Watch** 노드는 리스트의 리스트가 있음을 보여줍니다.
> 4. **PolyCurve.ByPoints** 노드는 각 리스트를 참조하고 각 polycurve를 작성합니다. Dynamo 미리보기에는 그리드의 각 행을 나타내는 4개의 polycurve가 있습니다.

![연습](../images/5-4/3/listsoflists-flatten02.jpg)

> 1. polycurve 노드 앞에 _flatten_ 을 삽입하여 모든 점에 대해 하나의 리스트를 작성했습니다. **PolyCurve.ByPoints** 노드는 리스트를 참조하여 하나의 곡선을 작성합니다. 모든 점은 하나의 리스트에 있으므로, 전체 점 리스트를 통과하는 하나의 지그재그 polycurve를 얻게 됩니다.

또한 격리된 데이터 티어를 단순화할 수도 있습니다. **List.Flatten** 노드를 사용하면 계층 상단에서 단순화할 지정된 수의 데이터 티어를 정의할 수 있습니다. 이는 워크플로우와 관련이 없을 수도 있는 복잡한 데이터 구조 문제로 고심하고 있는 경우에 정말 유용한 도구입니다. 또 다른 옵션은 **List.Map**에서 flatten 노드를 함수로 사용하는 것입니다. 아래에서 **List.Map**에 대해 자세히 알아보겠습니다.

### Chop

> 아래 링크를 클릭하여 예제 파일을 다운로드하십시오.
>
> 전체 예시 파일 리스트는 부록에서 확인할 수 있습니다.

{% file src="../datasets/5-4/3/Chop.dyn" %}

파라메트릭 모델링을 사용할 경우 기존 리스트에 데이터 구조를 수정해야 하는 경우도 있습니다. 여기에 여러 노드를 사용할 수도 있으며, chop이 가장 기본적인 버전입니다. chop을 사용하면 리스트를 설정된 항목 수의 하위 리스트로 분할할 수 있습니다.

chop 명령을 사용하면 지정된 리스트 길이를 기준으로 리스트가 분할됩니다. 어떤 면에서 chop은 flatten과 반대입니다. 즉, 데이터 구조를 제거하는 것이 아니라 새로운 티어를 데이터 구조에 추가합니다. 이 도구는 아래 예처럼 형상 작업에 유용한 도구입니다.

![연습](../images/5-4/3/listsoflists-chop.jpg)

### List.Map

> 아래 링크를 클릭하여 예제 파일을 다운로드하십시오.
>
> 전체 예시 파일 리스트는 부록에서 확인할 수 있습니다.

{% file src="../datasets/5-4/3/Map.dyn" %}

**List.Map/Combine**에서는 지정된 함수를 입력 리스트에 적용하지만 계층의 한 단계 아래에 적용합니다. 조합은 지정된 함수의 입력에 해당하는 여러 입력이 있을 수 있다는 점을 제외하고 맵과 동일합니다.

_참고: 이 연습은 이전 버전의 Dynamo로 작성되었습니다._ **List.Map** _기능의 대부분은_ **List@Level** _기능을 추가하여 해결되었습니다. 자세한 내용은 아래의_ [_List@Level_](3-lists-of-lists.md#lists-of-lists) _을 참조하십시오._

간단한 소개를 위해 이전 섹션의 **List.Count** 노드를 살펴보겠습니다.

**List.Count** 노드는 리스트의 모든 항목을 계산합니다. 이를 사용하여 **List.Map** 의 작동 방식을 보여드리겠습니다.

![](../images/5-4/3/listsoflists-map01.jpg)

> 1.  **Code Block**에 다음 두 줄의 코드를 삽입합니다. `-50..50..#Nx; -50..50..#Ny;`
>
>     이 코드를 입력하면 code block에서 Nx와 Ny에 대한 두 개의 입력을 작성합니다.
> 2. 두 개의 _integer sliders_ 를 사용하여 _Nx_ 및 _Ny_ 값을 **Code Block**에 연결하여 정의합니다.
> 3. code block의 각 줄을 **Point.ByCoordinates** 노드의 각 _X_ 및 _Y_ 입력에 연결합니다. 노드를 마우스 오른쪽 버튼으로 클릭하고 "레이싱"을 선택한 다음 _"외적"_ 을 선택합니다. 그러면 점의 그리드가 작성됩니다. 범위는 -50에서 50 사이로 정의했으므로 기본 Dynamo 그리드에 걸쳐 있습니다.
> 4. _**Watch**_ 노드에 작성된 점이 표시됩니다. 데이터 구조를 알 수 있습니다. 리스트의 리스트를 작성했습니다. 각 리스트에는 그리드 점의 행이 나타납니다.

![Exercise](<../images/5-4/3/lists of lists - map 02.jpg>)

> 1. 이전 단계에서 Watch 노드의 출력에 **List.Count** 노드를 부착합니다.
> 2. **Watch** 노드를 **List.Count** 출력에 연결합니다.

List.Count 노드는 5 값을 제공합니다. 이는 code block에 정의된 "Nx" 변수와 동일합니다. 그 이유는 무엇일까요?

* 먼저, **Point.ByCoordinates** 노드는 리스트를 작성하기 위한 기본 입력으로 "x" 입력을 사용합니다. Nx가 5이고 Ny가 3인 경우 각각 3개의 항목이 포함된 리스트의 리스트를 5개 얻게 됩니다.
* Dynamo에서는 리스트를 자체의 내부 객체로 취급하므로 **List.Count** 노드가 계층의 주 리스트에 적용됩니다. 결과는 값 5 또는 주 리스트의 리스트 수입니다.

![연습](../images/5-4/3/listsoflists-map03.jpg)

> 1. **List.Map** 노드를 사용하여 계층에서 한 단계 내려가 이 레벨에서 _"함수"_ 를 수행합니다.
> 2. **List.Count** 노드에 입력이 없습니다. 이 노드는 함수로 사용되고 있으므로 계층에서 한 단계 아래의 모든 개별 리스트에 **List.Count** 노드가 적용됩니다. **List.Count**의 빈 입력은 **List.Map**의 리스트 입력에 해당합니다.
> 3. 이제 **List.Count**의 결과로 각각 값이 3인 항목 5개의 리스트가 제공됩니다. 이는 각 하위 리스트의 길이를 나타냅니다.

### **List.Combine**

_참고: 이 연습은 이전 버전의 Dynamo로 작성되었습니다. List.Combine 기능의 대부분은_ **List@Level** _기능을 추가하여 해결되었습니다. 자세한 내용은 아래의_[_List@Level_](6-3\_lists-of-lists.md#listlevel) _을 참조하십시오._

이 연습에서는 **List.Combine**을 사용하여 별도의 객체 리스트에 함수를 적용하는 방법을 보여 줍니다.

먼저 두 점 리스트를 설정합니다.

![연습](../images/5-4/3/listsoflists-combined01.jpg)

> 1. **Sequence** 노드를 사용하여 각각 10단계로 증분하는 10개의 값을 생성합니다.
> 2. 결과를 **Point.ByCoordinates** 노드의 x 입력에 연결합니다. 이렇게 하면 Dynamo에 점 리스트가 작성됩니다.
> 3. 두 번째 **Point.ByCoordinates** 노드를 작업공간에 추가하고, 동일한 **Sequence** 출력을 x 입력으로 사용하되 **Interger Slider**를 해당 y 입력으로 사용하고, 해당 값을 31(첫 번째 점 세트와 겹치지 않는 한, 어떤 값도 사용할 수 있음)로 설정하여 두 점 세트가 서로 겹치지 않게 합니다.

다음으로 **List.Combine**을 사용하여 두 개의 개별 리스트에 있는 객체에 함수를 적용합니다. 이 경우 간단한 선 그리기 함수가 됩니다.

![연습](../images/5-4/3/listsoflists-combined02.jpg)

> 1. **List.Combine**을 작업공간에 추가하고 두 점 세트를 list0 및 list1 입력으로 연결합니다.
> 2. **Line.ByStartPointEndPoint**를 **List.Combine**에 대한 입력 함수로 사용합니다.

완료되면 두 점 세트가 **Line.ByStartPointEndPoint** 함수를 통해 압축/쌍으로 연결되며, Dynamo에서 10개의 선이 반환됩니다.

{% hint style="info" %}
 n-차원 리스트의 연습을 참조하여 List.Combine을 사용하는 또 다른 예제를 살펴보십시오. 
{% endhint %}

### List@Level

> 아래 링크를 클릭하여 예제 파일을 다운로드하십시오.
>
> 전체 예시 파일 리스트는 부록에서 확인할 수 있습니다.

{% file src="../datasets/5-4/3/Listatlevel.dyn" %}

**List.Map**을 선호하는 경우 **List@Level** 기능을 통해 노드의 입력 포트에서 바로 작업할 리스트 레벨을 선택할 수 있습니다. 이 기능을 이용하면 노드의 모든 수신 입력에 적용할 수 있으며 다른 방법보다 쉽고 빠르게 리스트의 레벨에 액세스할 수 있습니다. 입력으로 사용할 리스트의 레벨만 노드에 지정하고 노드에서 나머지 작업을 수행하도록 합니다.

이 연습에서는 **List@Level** 기능을 사용하여 특정 레벨의 데이터를 격리합니다.

![List@Level](../images/5-4/3/listsoflists-listatlevel01.jpg)

간단한 3D 점 그리드부터 시작하겠습니다.

> 1. 그리드는 X, Y, Z의 범위로 구성되며, 데이터는 X 리스트, Y 리스트, Z 리스트의 3가지 티어로 구성됩니다.
> 2. 이러한 티어는 서로 다른 **레벨**에 존재합니다. 레벨은 미리보기 버블 아래에 표시됩니다. 리스트 레벨 열은 위 리스트 데이터에 해당하므로 그 안에서 작업할 레벨을 식별하는 데 도움이 됩니다.
> 3. 리스트 레벨은 가장 낮은 레벨 데이터가 항상 "L1"에 오도록 역순으로 구성됩니다. 그러면 그래프가 업스트림으로 변경되는 경우에도 계획대로 작동할지 확인할 수 있습니다.

![List@Level](../images/5-4/3/listsoflists-listatlevel02.jpg)

> 1. **List@Level** 함수를 사용하려면 '>'을 클릭합니다. 이 메뉴 내에 두 개의 확인란이 있습니다.
> 2. **레벨 사용** - **List@Level** 기능을 사용할 수 있습니다. 이 옵션을 클릭하면 노드를 사용할 입력 리스트 레벨을 클릭하여 선택할 수 있습니다. 이 메뉴를 사용하면 위 또는 아래를 클릭하여 여러 레벨 옵션을 빠르게 시도할 수 있습니다.
> 3. _리스트 구조 유지_ \- 이 옵션을 사용하면 해당 입력의 레벨 구조를 유지할 수 있습니다. 경우에 따라 데이터를 고의적으로 하위 리스트로 구성했을 수 있습니다. 이 옵션을 선택하면 리스트 구성이 그대로 유지되고 정보가 손실되지 않습니다.

간단한 3D 그리드를 사용하면 리스트 레벨을 통해 전환하여 리스트 구조를 액세스하고 시각화할 수 있습니다. 각 리스트 레벨과 색인 조합은 원래 3D 세트와 다른 점 세트를 반환합니다.

![](../images/5-4/3/listsoflists-listatlevel03.jpg)

> 1. DesignScript의 "@L2"에서는 레벨 2의 리스트만 선택할 수 있습니다. 색인 0이 있는 레벨 2의 리스트는 첫 번째 Y 점 세트만 포함하여 XZ 그리드만 반환합니다.
> 2. 레벨 필터를 "L1"로 변경하면 첫 번째 리스트 레벨의 모든 항목을 볼 수 있습니다. 색인 0이 있는 레벨 1의 리스트는 모든 3D 점을 단순 리스트로 포함합니다.
> 3. "L3"에 대해 동일한 작업을 시도하는 경우 세 번째 리스트 레벨 점만 표시됩니다. 색인 0이 있는 레벨 3의 리스트에는 첫 번째 Z 점 세트만 포함되며 XY 그리드만 반환됩니다.
> 4. "L4"에 대해 동일한 작업을 시도하는 경우 세 번째 리스트 레벨 점만 표시됩니다. 색인 0이 있는 레벨 4의 리스트에는 첫 번째 X 점 세트만 포함되며 YZ 그리드만 반환됩니다.

이 특정 예는 **List.Map**에서도 작성할 수 있지만, **List@Level**에서는 상호작용을 크게 단순화하여 노드 데이터에 쉽게 액세스할 수 있게 합니다. 아래에서 **List.Map** 및 **List@Level** 메서드를 서로 비교하며 살펴보십시오.

![](../images/5-4/3/listsoflists-listatlevel04.jpg)

> 1. 두 메서드 모두 동일한 점에 대한 액세스를 제공하지만, **List@Level** 메서드를 사용하면 단일 노드 내의 데이터 도면층 간에 쉽게 전환할 수 있습니다.
> 2. **List.Map**을 사용하여 점 그리드에 액세스하려면 **List.Map**과 함께 **List.GetItemAtIndex** 노드를 사용해야 합니다. 단계를 내려가는 모든 리스트 레벨마다 추가 **List.Map** 노드를 사용해야 합니다. 리스트의 복잡도에 따라 적절한 레벨의 정보에 액세스하려면 그래프에 상당한 양의 **List.Map** 노드를 추가해야 할 수 있습니다.
> 3. 이 예에서는 **List.Map** 노드가 있는 **List.GetItemAtIndex** 노드가 '@L3'이 선택된 **List.GetItemAtIndex**와 동일한 리스트 구조를 가진 동일한 점 세트를 반환합니다.

### Transpose

> 아래 링크를 클릭하여 예제 파일을 다운로드하십시오.
>
> 전체 예시 파일 리스트는 부록에서 확인할 수 있습니다.

{% file src="../datasets/5-4/3/Transpose.dyn" %}

Transpose는 리스트의 리스트를 다룰 때 기본적인 함수입니다. 스프레드시트 프로그램과 마찬가지로 transpose는 데이터 구조의 열과 행을 반전합니다. 아래 기본 행렬을 사용하여 이 내용을 보여드리고, 다음 섹션에서는 Transpose를 사용하여 기하학적 관계를 작성할 수 있는 방법을 보여드리겠습니다.

![Transpose](../images/5-4/3/transpose1.jpg)

이전 연습에서 **List.Count** 노드를 삭제하고 일부 형상으로 이동하여 데이터 구조 방식을 살펴보겠습니다.

![](../images/5-4/3/listsoflists-transpose01.jpg)

> 1. **PolyCurve.ByPoints**를 **Point.ByCoordinates**의 Watch 노드의 출력에 연결합니다.
> 2. 출력에는 5개의 polycurve가 표시되며 Dynamo 미리보기에서는 곡선을 볼 수 있습니다. Dynamo 노드에서는 점 리스트(또는 이 경우 점 리스트의 리스트)를 찾고 여기에서 단일 polycurve를 작성합니다. 기본적으로 각 리스트가 데이터 구조에서 곡선으로 변환되었습니다.

![](../images/5-4/3/listsoflists-transpose02.jpg)

> 1. **List.Transpose** 노드는 모든 항목을 리스트의 리스트에 있는 모든 리스트로 바꿉니다. 이 방법은 복잡하게 들리지만 Microsoft Excel의 transpose와 동일한 논리입니다. 즉, 데이터 구조에서 열을 행으로 바꿉니다.
> 2. 추상 결과 확인: transpose로 인해 리스트 구조가 각각 3개의 항목이 있는 5개의 리스트에서 각각 5개의 항목이 있는 3개의 리스트로 바뀌었습니다.
> 3. 기하학적 결과 확인: **PolyCurve.ByPoints**를 사용하여 원래 곡선에 수직 방향으로 3개의 polycurve가 표시됩니다.

## 리스트 작성을 위한 Code Block

Code block 줄임에서는 "[]"을 사용하여 리스트를 정의합니다. 그러면 **List.Create** 노드보다 훨씬 빠르고 효율적인 방법으로 리스트를 작성할 수 있습니다. **Code block**에 대해서는 [Code Blocks 및 DesignScript](../../8\_coding\_in\_dynamo/8-1\_code-blocks-and-design-script/)에서 자세히 설명합니다. 아래 이미지를 참조하여 여러 표현식이 포함된 리스트를 code block으로 정의할 수 있는 방법을 확인하십시오.

![](../images/5-4/3/listsoflists-codeblockforlistcreation01.jpg)

#### Code Block 조회

**Code block** 축약형은 "[]"를 사용하여 복잡한 데이터 구조에서 원하는 특정 항목을 빠르고 쉽게 선택할 수 있습니다. **Code blocks**에 대해서는 [Code Block 및 DesignScript 장](../../8\_coding\_in\_dynamo/8-1\_code-blocks-and-design-script/)에서 자세히 설명합니다. 아래 이미지를 참조하여 여러 데이터 유형이 포함된 리스트를 code block으로 조회할 수 있는 방법을 확인하십시오.

![](../images/5-4/3/listsoflists-codeblockforlistcreation02.jpg)

## 연습 - 데이터 조회 및 삽입

> 아래 링크를 클릭하여 예제 파일을 다운로드하십시오.
>
> 전체 예시 파일 리스트는 부록에서 확인할 수 있습니다.

{% file src="../datasets/5-4/3/ReplaceItems.dyn" %}

이 연습에서는 이전 연습에서 설정한 몇 가지 논리를 사용하여 표면을 편집합니다. 여기서 우리의 목표는 직관적이지만 데이터 구조 탐색 시 더욱 관련성을 높이는 것입니다. 우리는 제어점을 이동하여 표면을 분명하게 표현하려고 합니다.

위 노드의 문자열로 시작합니다. 기본 Dynamo 그리드에 걸쳐 있는 기본 표면을 작성하고 있습니다.

![](../images/5-4/3/listoflists-exercisecbinsert\&query01.jpg)

> 1. **Code Block**을 사용하여 다음 두 코드 줄을 삽입하고 **Surface.PointAtParameter**의 _u_ 및 _v_ 입력에 각각 연결합니다. `-50..50..#3;` `-50..50..#5;`
> 2. **Surface.PointAtParameter**의 레이싱을 _"외적"_ 으로 설정해야 합니다.
> 3. **Watch** 노드에 각각 5개의 항목이 있는 리스트 3개의 리스트가 표시됩니다.

이 단계에서는 우리가 작성한 그리드의 중심점을 조회하려고 합니다. 이렇게 하려면 중간 리스트에서 중간 점을 선택합니다. 이해되시죠?

![](../images/5-4/3/listoflists-exercisecbinsert\&query02.jpg)

> 1. 이것이 올바른 점인지 확인하려면 Watch 노드 항목을 클릭하여 올바른 항목을 대상으로 하는지 확인할 수도 있습니다.
> 2. **Code Block**을 사용하여 다음과 같이 리스트의 리스트를 조회하기 위한 기본 코드 줄을 작성하겠습니다.\
 `points[1][2];`
> 3. **Geometry.Translate**를 사용하여 선택한 점을 _Z_ 방향으로 _20_ 단위씩 위로 이동할 것입니다.

![](../images/5-4/3/listoflists-exercisecbinsert\&query03.jpg)

> 1. **List.GetItemAtIndex** 노드가 있는 점의 중간 행도 선택하겠습니다. 참고: 이전 단계와 마찬가지로, `points[1];` 줄을 사용하여 **Code Block**으로 리스트를 조회할 수도 있습니다.

지금까지 중심점을 성공적으로 조회하여 위로 이동했습니다. 이제 이동한 이 점을 원래 데이터 구조에 다시 삽입해야 합니다.

![](../images/5-4/3/listoflists-exercisecbinsert\&query04.jpg)

> 1. 먼저, 이전 단계에서 격리한 리스트의 항목을 대치하려고 합니다.
> 2. **List.ReplaceItemAtIndex**를 사용하여 _"2"_ 의 색인으로 중간 항목을 이동된 점에 연결된 대치 항목(**Geometry.Translate**)으로 대치할 것입니다.
> 3. 이 출력은 이동된 점을 리스트의 중간 항목으로 입력했음을 보여줍니다.

이제 리스트를 수정했으므로 이 리스트를 원본 데이터 구조(리스트의 리스트)에 다시 삽입해야 합니다.

![](../images/5-4/3/listoflists-exercisecbinsert\&query05.jpg)

> 1. 동일한 논리 다음에 **List.ReplaceItemAtIndex**를 사용하여 중간 리스트를 수정된 리스트로 대치합니다.
> 2. 이러한 두 노드의 색인을 정의하는 **Code Block** 은 1과 2이며, **Code Block**(_points[1][2]_)의 원래 조회와 일치합니다.
> 3. _index 1_ 에서 리스트를 선택하면 Dynamo 미리보기에 데이터 구조가 강조 표시됩니다. 이동된 점을 원래 데이터 구조에 병합했습니다.

이 점 세트에서 표면을 만드는 여러 가지 방법이 있습니다. 이 경우 곡선을 함께 로프트하여 표면을 작성하겠습니다.

![](../images/5-4/3/listoflists-exercisecbinsert\&query06.jpg)

> 1. **NurbsCurve.ByPoints** 노드를 작성하고 새 데이터 구조를 연결하여 세 개의 NURBS 곡선을 작성합니다.

![](../images/5-4/3/listoflists-exercisecbinsert\&query07.jpg)

> 1. **Surface.ByLoft**를 **NurbsCurve.ByPoints**의 출력에 연결합니다. 이제 수정된 표면이 있습니다. 형상의 원래 _Z_ 값을 변경할 수 있습니다. 변환 후 형상 업데이트를 확인하십시오!
