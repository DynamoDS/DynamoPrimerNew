# Списки списков

### Списки списков

Добавим еще один уровень в иерархию. Если взять колоду карт из первого примера и создать рамку, в которой будет находиться несколько колод, то эта рамка будет представлять собой список колод, а каждая колода — список карт. Это и есть список списков. В качестве аналогичного примера для этого раздела ниже представлен список столбиков монет, каждый из которых содержит список монет.

![Монеты](../images/5-4/3/coins-521245\_640.jpg)

> Фотография предоставлена [Дори (Dori)](https://commons.wikimedia.org/wiki/File:Stack\_of\_coins\_0214.jpg).

### Query

Какие **запросы** доступны в таком списке списков? Таким образом можно вызвать существующие свойства.

* Сколько всего типов монет? 2.
* Какова ценность типов монет? 0,01 долл. США и 0,25 долл. США.
* Какие материалы используются для изготовления монет номиналом 0,25 долл. США? 75 % меди и 25 % никеля.
* Какие материалы используются для изготовления цента? 97,5 % цинка и 2,5 % меди.

### Action

Какие **действия** можно выполнять со списком списков? Они приведут к изменению списка списков в зависимости от конкретной операции.

* Выбрать один столбик из монет номиналом 1 или 25 центов.
* Выбрать одну монету номиналом 1 или 25 центов.
* Переупорядочить столбики.
* Перемешать столбики.

Для каждой из перечисленных выше операций в Dynamo имеется отдельный узел. Поскольку мы работаем с абстрактными данными, а не с физическими объектами, необходимо установить набор правил, определяющих порядок перемещения вверх и вниз по иерархии данных.

При работе со списками списков данные располагаются по слоям и имеют сложную структуру, но это дает возможность выполнять ряд уникальных параметрических операций. Остановимся подробнее на основных операциях, оставив другие для последующих занятий.

## Упражнение

### Нисходящая иерархия

> Скачайте файл с примером, щелкнув ссылку ниже.
>
> Полный список файлов с примерами можно найти в приложении.

{% file src="../datasets/5-4/3/Top-Down-Hierarchy.dyn" %}

В данном разделе необходимо усвоить один базовый принцип: **Dynamo рассматривает списки как объекты самих себя, расположенные в самих себе**. Эта нисходящая иерархия разработана с учетом объектно-ориентированного программирования. Вместо выбора вложенных элементов с помощью, например, команды **List.GetItemAtIndex** в Dynamo будет выбран индекс основного списка в структуре данных. Этот объект, в свою очередь, может быть другим списком. Рассмотрим этот вопрос подробнее на примере изображения ниже.

![top-down](<../images/5-4/3/lists of lists - top down hierachy.jpg>)

> 1. С помощью узла **Code Block** было задано два диапазона: `0..2; 0..3;`.
> 2. Эти диапазоны соединены с узлом **Point.ByCoordinates**, а в качестве переплетения выбран вариант _Cross Product_ (векторное произведение). При этом создается сетка точек, а в качестве выходных данных возвращается список списков.
> 3. Обратите внимание, что узел **Watch** содержит 3 списка с 4 элементами в каждом.
> 4. При использовании функции **List.GetItemAtIndex** с индексом 0, Dynamo выберет первый список и все его содержимое. Другие программы могут выбрать первый элемент каждого списка в структуре данных, но в Dynamo при работе с данными используется иерархия «сверху вниз».

### List.Flatten

> Скачайте файл с примером, щелкнув ссылку ниже.
>
> Полный список файлов с примерами можно найти в приложении.

{% file src="../datasets/5-4/3/Flatten.dyn" %}

Функция Flatten удаляет все уровни в структуре данных. Это удобно, если для выполнения операции не требуется наличие иерархий данных, но имеются определенные риски, так как удаляется информация. В примере ниже показан результат выравнивания списка данных.

![Exercise](<../images/5-4/3/lists of lists - flatten 01.jpg>)

> 1. Вставьте одну строку кода для определения диапазона в узле **Code Block**: `-250..-150..#4;`.
> 2. При вставке _блока кода_ во входные данные _x_ и _y_ узла **Point.ByCoordinates** в качестве варианта переплетения укажем _Cross Product_ (векторное произведение), чтобы получить сетку точек.
> 3. Узел **Watch** показывает наличие списка списков.
> 4. Узел **PolyCurve.ByPoints** создаст ссылки для каждого списка и построит соответствующую сложную кривую. Обратите внимание, что в области предварительного просмотра Dynamo отобразятся четыре сложные кривые, представляющие каждый ряд сетки.

![Exercise](<../images/5-4/3/lists of lists - flatten 02.jpg>)

> 1. После вставки функции _Flatten_ перед узлом сложной кривой был создан один список для всех точек. Узел **PolyCurve.ByPoints** создает ссылку для списка, чтобы создать одну кривую, а так как все точки находятся в одном списке, получается одна зигзагообразная сложная кривая, которая проходит по всему списку точек.

Можно также выровнять изолированные уровни данных. С помощью узла **List.Flatten** можно указать определенное количество уровней данных, выравниваемых от верхнего уровня иерархии. Это очень полезный инструмент при работе со сложными структурами данных, которые могут быть не нужны в рабочем процессе. Еще один вариант — использовать узел Flatten в качестве функции в **List.Map**. Далее мы подробнее обсудим **List.Map**.

### Chop

> Скачайте файл с примером, щелкнув ссылку ниже.
>
> Полный список файлов с примерами можно найти в приложении.

{% file src="../datasets/5-4/3/Chop.dyn" %}

При параметрическом моделировании бывает необходимо изменить структуру данных в существующем списке. С этой целью можно использовать множество других узлов, из которых Chop — самая базовая версия. С помощью функции Chop можно разделить список на вложенные списки с заданным количеством элементов.

Команда Chop (обрезка) делит списки на основе заданной длины списка. В некотором смысле обрезка обратна выравниванию: вместо упрощения структуры данных она добавляет в нее новые уровни. Это удобный инструмент для геометрических операций, таких как в примере ниже.

![Exercise](<../images/5-4/3/lists of lists - chop.jpg>)

### List.Map

> Скачайте файл с примером, щелкнув ссылку ниже.
>
> Полный список файлов с примерами можно найти в приложении.

{% file src="../datasets/5-4/3/Map.dyn" %}

Узел **List.Map/Combine** позволяет применить заданную функцию к списку входных данных, но на один шаг вниз по иерархии. Набор комбинаций аналогичен команде Maps, за исключением наличия нескольких наборов входных данных, соответствующих входным данным заданной функции.

_Примечание. Это упражнение было создано в предыдущей версии Dynamo. Большая часть функциональных возможностей_ **List.Map** _была упразднена с добавлением функции_ **List@Level**_. Дополнительные сведения см. в разделе_ [_List@Level_](6-3\_lists-of-lists.md#listlevel) _ниже._

В качестве краткого введения рассмотрим узел **List.Count** из предыдущего раздела.

Узел **List.Count** подсчитывает все элементы в списке. Мы воспользуемся этим для демонстрации работы **List.Map**.

![](<../images/5-4/3/lists of lists - map 01.jpg>)

> 1. Вставьте следующие две строки кода в узел **Code Block**: `-50..50..#Nx; -50..50..#Ny;`.
>
>    После ввода этих данных блок кода создаст два набора входных данных для Nx и Ny.
> 2. С помощью двух узлов _Integer Slider_ задайте значения _Nx_ и _Ny_ путем их присоединения к **Code Block**.
> 3. Соедините каждую строку блока кода с соответствующими входными данными _X_ и _Y_ узла **Point.ByCoordinates**. Щелкните узел правой кнопкой мыши, выберите Lacing (переплетение), а затем _Cross Product_ (векторное произведение). Будет создана сетка точек. Так как мы определили диапазон от -50 до 50, он охватывает сетку Dynamo по умолчанию.
> 4. Созданные точки отображаются в узле _**Watch**_. Обратите внимание на структуру данных. Мы создали список списков. Каждый список представляет собой ряд точек сетки.

![Exercise](<../images/5-4/3/lists of lists - map 02 (1).jpg>)

> 1. Вставьте узел **List.Count** в выходные данные узла Watch из предыдущего шага.
> 2. Соедините узел **Watch** с выходными данными **List.Count**.

Обратите внимание, что узел List.Count выдает значение 5. Это значение равно переменной Nx, заданной в блоке кода. Почему?

* Во-первых, в качестве основного входного параметра для создания списков в узле **Point.ByCoordinates** используется входной параметр x. Если Nx равно 5, а Ny — 3, получается список, состоящий из 5 списков, в каждом из которых содержится 3 элемента.
* Так как Dynamo рассматривает списки как объекты самих себя, расположенные в самих себе, то узел **List.Count** применяется к основному списку в иерархии. В результате получается значение 5 (количество списков в главном списке).

![Exercise](<../images/5-4/3/lists of lists - map 03.jpg>)

> 1. С помощью узла **List.Map** спустимся на один шаг вниз по иерархии и на этом уровне выполним _функцию_.
> 2. Обратите внимание, что узел **List.Count** не имеет входных данных. Так как узел **List.Count** используется в качестве функции, он будет применен к каждому отдельному списку на один шаг вниз по иерархии. Пустые входные данные узла **List.Count** соответствуют входным данным списка в узле **List.Map**.
> 3. Результаты **List.Count** теперь выдают список из 5 элементов, в каждом из которых имеется значение 3. Это соответствует длине каждого вложенного списка.

### **List.Combine**

_Примечание. Это упражнение было создано в предыдущей версии Dynamo. Большая часть функциональных возможностей List.Combine была упразднена с добавлением функции_ **List@Level**_. Дополнительные сведения см. в разделе_ [_List@Level_](6-3\_lists-of-lists.md#listlevel) _ниже._

В этом упражнении узел **List.Combine** используется, чтобы продемонстрировать, как его с его помощью можно применять функцию к отдельным спискам объектов.

Начните с настройки двух списков точек.

![Exercise](<../images/5-4/3/lists of lists - combined 01.jpg>)

> 1. Используйте узел **Sequence** для создания 10 значений, каждое с увеличением на 10.
> 2. Соедините результат с входным параметром «x» узла **Point.ByCoordinates**. В Dynamo будет создан список точек.
> 3. Добавьте второй узел **Point.ByCoordinates** в рабочее пространство. Используйте тот же выходной параметр **Sequence** в качестве входного параметра x, но добавьте **Interger Slider** в качестве входного параметра y и задайте для него значение 31 (оно может быть любым, если не перекрывается первым набором точек), чтобы два набора точек не перекрывались друг другом.

Используйте **List.Combine**, чтобы применить функцию к объектам в 2 отдельных списках. В данном случае это будет простая функция рисования линий.

![Exercise](<../images/5-4/3/lists of lists - combined 02.jpg>)

> 1. Добавьте узел **List.Combine** в рабочее пространство и соедините 2 набора точек в качестве входных данных list0 и list1.
> 2. Используйте узел **Line.ByStartPointEndPoint** в качестве входной функции для узла **List.Combine**.

После этого 2 набора точек с помощью функции **Line.ByStartPointEndPoint** архивируются или связываются вместе и в Dynamo возвращаются 10 строк.

{% hint style="info" %}
См. упражнение в многомерных списках для просмотра другого примера использования List.Combine.
{% endhint %}

### List@Level

> Скачайте файл с примером, щелкнув ссылку ниже.
>
> Полный список файлов с примерами можно найти в приложении.

{% file src="../datasets/5-4/3/Listatlevel.dyn" %}

В отличие от **List.Map** функция **List@Level** позволяет выбрать необходимый уровень списка непосредственно на входном порте узла. Эту функцию можно применять ко всем поступающим входным данным узлов и получать доступ к уровням списков быстрее, чем при использовании других методов. Просто сообщите узлу, какой уровень списка требуется использовать в качестве входных данных, и он сам сделает все необходимое.

В этом упражнении с помощью функции **List@Level** изолируется определенный уровень данных.

![List@Level](<../images/5-4/3/lists of lists - list at level 01.jpg>)

Начнем с простой 3D-сетки точек.

> 1. Поскольку сетка создается с диапазоном для X, Y и Z, структура данных будет иметь 3 уровня: список X, список Y и список Z.
> 2. Эти уровни расположены на разной высоте (**уровнях**). Они указаны в нижней части марки предварительного просмотра. Столбцы уровня списка соответствуют данным списка выше, что позволяет быстрее найти нужный уровень.
> 3. Уровни списка располагаются в обратном порядке, так что данные самого низкого уровня всегда находятся на высоте L1. Благодаря этому графики будут функционировать запланированным образом, даже если что-то изменится в предыдущем алгоритме.

![List@Level](<../images/5-4/3/lists of lists - list at level 02.jpg>)

> 1. Чтобы использовать функцию **List@Level**, нажмите кнопку «>». В меню отобразятся два флажка.
> 2. **Используйте уровни**: этот параметр включает функцию **List@Level**. После выбора этого параметра можно с помощью мыши выбрать уровни списка входных данных, которые будут использованы узлом. С помощью этого меню можно быстро проверить различные конфигурации уровней, щелкая мышью выше или ниже.
> 3. _Сохранить структуру списков_: если установить этот флажок, можно будет сохранить структуру уровней этих входных данных. Иногда данные бывают сознательно разделены по вложенным спискам. Если установить этот флажок, можно сохранить структуру списка неизменной без какой-либо потери информации.

Благодаря этой простой 3D-сетке можно получить доступ к структуре списка и визуализировать ее, переключаясь между уровнями списка. Любая комбинация уровня списка и индекса возвращает собственный набор точек из исходного 3D-набора.

![](<../images/5-4/3/lists of lists - list at level 03.jpg>)

> 1. С помощью элемента @L2 в DesignScript можно выбрать только список на уровне 2. Список на уровне 2 с индексом 0 включает в себя только первый набор точек Y и возвращает только сетку XZ.
> 2. Если задать фильтр уровней L1, можно увидеть все содержимое первого уровня списка. Список на уровне 1 с индексом 0 включает в себя все 3D-точки в одноуровневом списке.
> 3. В аналогичном случае с L3 будут видны только точки третьего уровня списка. Список на уровне 3 с индексом 0 включает в себя только первый набор точек Z и возвращает только сетку XY.
> 4. В аналогичном случае с L4 будут видны только точки третьего уровня списка. Список на уровне 4 с индексом 0 включает в себя только первый набор точек X и возвращает только сетку YZ.

Несмотря на то что данный конкретный пример можно воссоздать с помощью **List.Map**, функция **List@Level** существенно упрощает операцию и доступ к данным узла. Ниже представлено сравнение методов **List.Map** и **List@Level**.

![](<../images/5-4/3/lists of lists - list at level 04.jpg>)

> 1. Оба метода предоставляют доступ к одним и тем же точкам, однако **List@Level** позволяет легко переключаться между слоями данных в одном узле.
> 2. Для доступа к сетке точек с помощью **List.Map** требуется добавить узел **List.GetItemAtIndex** в дополнение к **List.Map**. Для каждого нижестоящего уровня списка необходимо использовать дополнительный узел **List.Map**. В некоторых сложных списках для получения доступа к нужному уровню информации требуется включение в график значительного количества узлов **List.Map**.
> 3. В этом примере узел **List.GetItemAtIndex** с узлом **List.Map** возвращает тот же набор точек и ту же структуру списка, что и **List.GetItemAtIndex** со значением @L3.

### Transpose

> Скачайте файл с примером, щелкнув ссылку ниже.
>
> Полный список файлов с примерами можно найти в приложении.

{% file src="../datasets/5-4/3/Transpose.dyn" %}

Transpose (транспонирование) — это одна из основных функций при работе со списками списков. Как и в электронных таблицах, при транспонировании происходит перестановка столбцов и строк в структуре данных. Продемонстрируем это с помощью следующей базовой матрицы, а в следующем разделе покажем, как с помощью функции транспонирования создавать геометрические взаимосвязи.

![Transpose](../images/5-4/3/transpose1.jpg)

Удалите узлы **List.Count** из предыдущего упражнения и перенесите их на геометрические объекты, чтобы увидеть, как структурированы данные.

![](<../images/5-4/3/lists of lists - transpose 01.jpg>)

> 1. Соедините узел **PolyCurve.ByPoints** с выходными данными узла Watch от узла **Point.ByCoordinates**.
> 2. На выходе отобразятся 5 сложных кривых, которые можно видеть в области предварительного просмотра Dynamo. Узел Dynamo выполняет поиск списка точек (в данном случае — списка списков точек) и создает из них одну сложную кривую. По сути, каждый список в структуре данных преобразован в кривую.

![](<../images/5-4/3/lists of lists - transpose 02.jpg>)

> 1. Узел **List.Transpose** переставляет все элементы со всеми списками в списке списков. Это может показаться сложным, но в Microsoft Excel используется точно такая же логическая схема транспонирования данных: перестановка столбцов со строками в структуре данных.
> 2. Обратите внимание на изменение в списках: после транспонирования структура, состоявшая из 5 списков с 3 элементами, изменилась на 3 списка с 5 элементами в каждом.
> 3. Кроме того, обратите внимание на изменение в геометрии: использование узла **PolyCurve.ByPoints** привело к появлению 3 сложных кривых в перпендикулярном направлении к исходным кривым.

## Применение Code Block для создания списка

Для определения списка в сокращенном языке узла Code Block используются квадратные скобки (\[]). Это гораздо более быстрый и простой способ создания списков, чем с помощью узла **List.Create**. Узел **Code Block** подробно рассматривается в разделе [Узлы Code Block и DesignScript](../../8\_coding\_in\_dynamo/8-1\_code-blocks-and-design-script/). На изображении ниже показано, как можно задать список с несколькими выражениями с помощью блока кода.

![](<../images/5-4/3/lists of lists - codeblock for list creation 01.jpg>)

#### Запрос блока кода

Для упрощенного выбора определенных элементов, которые требуется извлечь из сложной структуры данных, в сокращенном языке узла **Code Block** используются квадратные скобки (\[]). Узлы **Code Block** подробно рассматриваются в главе [Узлы Code Block и DesignScript](../../8\_coding\_in\_dynamo/8-1\_code-blocks-and-design-script/). На изображение ниже показано, как запросить список с несколькими типами данных с помощью блока кода.

![](<../images/5-4/3/lists of lists - codeblock for list creation 02.jpg>)

## Упражнение «Запрос и вставка данных»

> Скачайте файл с примером, щелкнув ссылку ниже.
>
> Полный список файлов с примерами можно найти в приложении.

{% file src="../datasets/5-4/3/ReplaceItems.dyn" %}

В этом упражнении для редактирования поверхности используется логическая схема из предыдущего упражнения. Эту задачу можно решить интуитивным способом, однако при этом потребуется дополнительная навигация по структуре данных. Необходимо определить поверхность путем перемещения контрольной точки.

Начните со строки узлов выше. Создайте базовую поверхность, которая охватывает всю сетку Dynamo по умолчанию.

![](<../images/5-4/3/list of lists - exercise cb insert & query 01.jpg>)

> 1. С помощью узла **Code Block** вставьте следующие две строки кода и соедините их с входными параметрами _u_ и _v_ узла **Surface.PointAtParameter** соответственно: `-50..50..#3;` `-50..50..#5;`.
> 2. Убедитесь, что для параметра Lacing (переплетение) узла **Surface.PointAtParameter** задано значение _Cross Product_ (векторное произведение).
> 3. Узел **Watch** показывает, что имеется список из 3 списков, каждый из которых содержит 5 элементов.

На этом этапе следует запросить центральную точку созданной сетки. Для этого выберите центральную точку в списке посередине. Логично, не так ли?

![](<../images/5-4/3/list of lists - exercise cb insert & query 02.jpg>)

> 1. Чтобы убедиться в правильности выбора точки, можно щелкнуть элементы узла Watch для проверки правильности выбора элемента.
> 2. При помощи узла **Code Block** создайте базовую строку кода для запроса списка списков:\
>    `points[1][2];`
> 3. С помощью функции **Geometry.Translate** переместите выбранную точку вверх в направлении оси _Z_ на _20_ единиц.

![](<../images/5-4/3/list of lists - exercise cb insert & query 03.jpg>)

> 1. Кроме того, выберите ряд точек посредине с помощью узла **List.GetItemAtIndex**. Примечание. Как и при выполнении предыдущего шага, можно запросить список с помощью узла **Code Block**, используя строку `points[1];`.

Итак, мы успешно запросили центральную точку и переместили ее вверх. Теперь необходимо вставить эту перемещенную точку обратно в исходную структуру данных.

![](<../images/5-4/3/list of lists - exercise cb insert & query 04.jpg>)

> 1. Сначала замените элемент списка, который был изолирован при выполнении предыдущего шага.
> 2. С помощью узла **List.ReplaceItemAtIndex** замените центральный элемент с помощью индекса _2_ на замещающий элемент, соединенный с перемещенной точкой (**Geometry.Translate**).
> 3. Выходные данные показывают, что перемещенная точка была вставлена в набор входных данных элемента в середине списка.

После изменения списка необходимо вставить его обратно в исходную структуру данных — список списков.

![](<../images/5-4/3/list of lists - exercise cb insert & query 05.jpg>)

> 1. Используя ту же логическую схему, заменим список в середине на измененный список с помощью узла **List.ReplaceItemAtIndex**.
> 2. Обратите внимание, что индекс этих двух узлов определяется узлами **Code Block**__ 1 и 2, что соответствует исходному запросу узла **Code Block** (_points\[1]\[2]_).
> 3. Если выбрать список с помощью _index 1_, то структура данных будет выделена в области предварительного просмотра Dynamo. Итак, мы успешно встроили перемещенную точку в исходную структуру данных.

Существует множество способов создания поверхности из этого набора точек. В данном случае необходимо создать поверхность за счет лофтинга кривых.

![](<../images/5-4/3/list of lists - exercise cb insert & query 06.jpg>)

> 1. Создайте узел **NurbsCurve.ByPoints** и присоедините новую структуру данных для создания трех NURBS-кривых.

![](<../images/5-4/3/list of lists - exercise cb insert & query 07.jpg>)

> 1. Соедините узел **Surface.ByLoft** с выходными данными из узла **NurbsCurve.ByPoints**. Получится модифицированная поверхность. Можно изменить исходное значение _Z_ геометрии. Выполните преобразование и посмотрите, как изменится геометрия.
