# ロジック

**ロジック**(正確には**条件付きロジック**)により、テストに基づく単一のアクションや一連のアクションを指定することができます。テストの評価を行うと、`True` または `False` のブール値が返されます。このブール値を使用して、プログラム フローをコントロールすることができます。

### ブール値

数値変数には、さまざまな数値の範囲全体を格納することができます。ブール変数には、True または False、Yes または No、1 または 0 など、2 つの値のみを格納することができます。このようにブール値の範囲は限られているため、ブール値を使用して計算を行うことはほとんどありません。

### 条件ステートメント

If ステートメントは、プログラミングにおける重要な概念です。このステートメントは、「_この条件_が真である場合は_この処理_を実行し、偽である場合は_別の処理_を実行する」という形式で記述されます。 このステートメントの結果として出力されるアクションは、ブール値によって制御されます。Dynamo で If ステートメントを定義する場合、いくつかの方法があります。

| アイコン | 名前(構文) | 入力 | 出力 |
| ----------------------------------------------- | ------------------------- | ----------------- | ------- |
| ![](<../images/5-3/3/If.jpg>) | If (**If**) | test、true、false | result |
| ![](../images/5-3/3/Formula.jpg) | Formula (**IF(x,y,z)**) | x、y、z | result |
| ![](<../images/5-3/3/Code Block.jpg>) | Code Block (**(x?y:z);**) | x ? y、z | result |

ここでは簡単な例を使用して、If 条件ステートメントを使用する 3 つのノードの動作を確認していきます。

上の図では、_Boolean_ ノードの出力値が _True_ に設定されているため、その結果として "_this is the result if true_" という文が表示されます。この場合、_If_ ステートメントを構成する 3 つのノードの動作は同じになります。

![](<../images/5-3/3/logic - conditional statements 01 false.jpg>)

繰り返しますが、これら 3 つのノードの動作はすべて同じになります。_ブール値_ を _False_ に変更すると、元の _If_ ステートメントで定義されているとおりに、出力結果の値が _Pi_ になります。

![x](<../images/5-3/3/logic - conditional statements 02 true.jpg>)

## 演習: ロジックとジオメトリ

> 下のリンクをクリックして、サンプル ファイルをダウンロードします。
>
> すべてのサンプル ファイルの一覧については、付録を参照してください。

{% file src="../datasets/5-3/3/Building Blocks of Programs - Logic.dyn" %}

### パート I: リストをフィルタする

1. ここでは、ロジックを使用して、数値のリストを偶数のリストと奇数のリストに分割してみましょう。

![](<../images/5-3/3/logic - exercise part I-01.jpg>)

> a. **Number Range** ノードを使用して、数値の範囲をキャンバスに追加します。
>
> b. **Number** ノードを使用して、3 つの Number ノードをキャンバスに追加します。各 Number ノードで、次のように値を指定します。_start_ 入力: _0.0_、_end_ 入力: _10.0_、_step_ 入力: _1.0_。
>
> c. **Output** として、0 から 10 までの範囲にわたる 11 個の数値のリストが生成されます。
>
> d. 「**(%)**」ノード(モジュロ演算ノード)の _x_ 入力に **Number Range** ノードを接続し、_y_ 入力に _2.0_ を指定します。この操作により、リスト内の各数値を 2 で除算した場合の余りが算出されます。このリストの出力値は、0 と 1 が交互に現れる数値のリストになります。
>
> e. 「**(==)** 」ノード(等価テスト ノード)を使用して、キャンバスに等価テストを追加します。「_(%)_」ノードの出力を「(==)」ノードの _x_ 入力に接続し、Number ノードの _0.000_ 出力を「(==)」ノードの _y_ 入力に接続します。
>
> f. **Watch** ノードを使用して、等価テストの出力が true と false の値を交互に繰り返すリストになっていることを確認します。これらの値を使用して、リスト内の項目が区別されます。_0_ (または _true_)は偶数を表し、_1_ (または _false_)は奇数を表します。
>
> g. **List.FilterByBoolMask** ノードは、ブール値の入力に基づいて数値をフィルタし、2 つの異なるリストに分割します。元の _数値の範囲_ を _list_ 入力に接続し、「(==)」ノードの出力を _mask_ 入力に接続します。 _in_ 出力は true の値を表し、_out_ 出力は false の値を表します。
>
> h. **Watch** ノードを使用して、偶数のリストと奇数のリストが生成されたことを確認します。これで、論理演算子を使用して、リストがパターン別に分類されました。

### パート II: ロジックからジオメトリへ

ここでは、最初の演習で作成したロジックを変更してモデリング操作に適用してみましょう。

2\. ここでも、前の演習と同じノードを使用します。ただし、次のように、いくつか違いがあります。

![](<../images/5-3/3/logic - exercise part II-01.jpg>)

> a. これらの入力値で **Sequence** ノードを使用します。
>
> b. **List.FilterByBoolMask** ノードの list 入力に対する接続が解除されています。これらのノードは、この演習の後半で使用します。

3\. 最初に、上の図に示されているように、グラフの別のグループを作成します。このノード グループは、曲線を定義するためのパラメータ制御式を表しています。ここで、次の点に注意する必要があります。

![](<../images/5-3/3/logic - exercise part II-02.jpg>)

> a. 最初の **Number Slider** は、波の周波数を表します。最小 1、最大 4、ステップ 0.01 の値である必要があります。
>
> b. 2 番目の **Number Slider** は、波の振幅を表します。最小 0、最大 1、ステップ 0.01 の値である必要があります。
>
> c. **PolyCurve.ByPoints** ノードにより、上図のとおりにノード ダイアグラムを構成した時点で、Dynamo のプレビューに正弦曲線が出力されます。

ここでは、静的なプロパティで Number ノードを使用し、動的なプロパティで Number Slider ノードを使用して入力を行います。この手順の最初で定義した元の数値の範囲をそのまま使用してもかまいませんが、ここで作成する正弦曲線に対して、ある程度の柔軟性を設定しておく必要があります。Number Slider ノードの値を変更して、曲線の周波数と振幅がどのように変化するかを確認してください。

![](<../images/5-3/3/logic - exercise part II-03.gif>)

4\. ここで少し先回りをして、最終的な結果を確認しましょう。個別に作成した最初の 2 つのステップを接続する必要があります。基本の正弦曲線を使用して、ジッパー状のコンポーネントの位置をコントロールし、真偽判定のロジックを使用して、小さなボックスと大きなボックスを交互に配置します。

![](<../images/5-3/3/logic - exercise part II-04.jpg>)

> a. ステップ 02 で作成された数値シーケンスを使用し、**Math.RemapRange** ノードで再マッピングして、新しい一連の数値を作成します。元の数値の範囲は、0 から 100 までになります(step 値 1)。新しい数値の範囲は、0 から 1 になります。最小値の 0 を _newMin_ 入力に接続し、最大値の 1 を _newMax_ 入力に接続します。

5\. **Curve.PointAtParameter** ノードを作成し、ステップ 04 の **Math.RemapRange** 出力を _param_ 入力として接続します。

![](<../images/5-3/3/logic - exercise part II-05.jpg>)

この操作により、曲線に沿って点群が作成されます。ここでは数値の範囲を 0 から 1 までの範囲に再マッピングしましたが、その理由は、_param_ 入力に 0 から 1 までの範囲の値を指定する必要があるためです。_0_ の値は始点を表し、_1_ の値は終点を表します。すべての中間値は、_\[0,1]_ の範囲内で評価されます。

6\. **Curve.PointAtParameter** ノードの出力を **List.FilterByBoolMask** ノードに接続し、奇数インデックスと偶数インデックスのリストを分離します。

![](<../images/5-3/3/logic - exercise part II-06.jpg>)

> a. **List.FilterByBoolMask** ノードの _list_ 入力に、前の手順で使用した **Curve.PointAtParameter** ノードを接続します。
>
> b. **Watch** ノードを _in_ 出力と _out_ 出力に 1 つずつ接続し、偶数値のインデックスを表すリストと奇数値のインデックスを表す 2 つのリストが生成されたことを確認します。これらの点群は、曲線上に同じ方法で配置されます。これについては、次の手順で確認します。

7\. 次に、ステップ 05 で **List.FilterByBoolMask** ノードの出力結果を使用して、インデックスに従ってサイズが設定されたジオメトリを生成します。

**Cuboid.ByLengths** ノードを上の図のように接続し、正弦曲線に沿ったジッパー構造を作成します。ノード名の「Cuboid」とは、直方体という意味です。ここでは、直方体の中央に位置する曲線上の点を基準として、直方体のサイズを定義します。この操作により、偶数と奇数の除算ロジックがモデル内に明示的に定義されます。

![](<../images/5-3/3/logic - exercise part II-07.jpg>)

> a. 偶数インデックスの直方体のリスト。
>
> b. 奇数インデックスの直方体のリスト。

できました!この演習で説明したロジック演算に従ってジオメトリ寸法を定義するプロセスをプログラムしました。
