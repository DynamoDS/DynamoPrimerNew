# Логика

**Логика** (точнее **условная логика**) позволяет задать действие или набор действий в зависимости от результата проверки. После прохождения проверки выдается логическое значение `True` или `False`, которое можно использовать для управления ходом программы.

### Логические выражения

Числовые переменные могут хранить целый диапазон различных чисел. В логических переменных хранятся только два значения: «Истина» или «Ложь», да или нет, 1 или 0. Из-за ограниченной применимости логические операции можно не так часто встретить в расчетах.

### Условные выражения

Выражение If является ключевым для программирования. Если _некое условие_ истинно, то происходит _что-то одно_, в противном случае происходит _что-то другое_. Действие, выполняемое после проверки с помощью данного выражения, зависит от логического значения. Существует несколько способов определения выражения If в Dynamo.

| Значок | Имя (синтаксис) | Входные данные | Выходные данные |
| ----------------------------------------------- | ------------------------- | ----------------- | ------- |
| ![](<../images/5-3/3/If.jpg>) | If (**If**) | test, true, false | результат |
| ![](../images/5-3/3/Formula.jpg) | Formula (**IF(x,y,z)**) | x, y, z | результат |
| ![](<../images/5-3/3/Code Block.jpg>) | Code Block (**(x?y:z);**) | x? y, z | результат |

Рассмотрим краткий пример с каждым из этих трех узлов в действии, используя условное выражение If.

На этом изображении в узле _boolean_ задано значение _true_. Это означает, что на выводе появится строка _this is the result if true (это результат при истинном значении)._ Три узла, образующие выражение _If_, работают одинаково.

![](<../images/5-3/3/logic - conditional statements 01 false.jpg>)

Напомним, что узлы работают одинаково. Если изменить значение _boolean_ на _false_, результатом будет число _пи_, как определено в исходном операторе _If_.

![x](<../images/5-3/3/logic - conditional statements 02 true.jpg>)

## Упражнение «Логика и геометрия»

> Скачайте файл с примером, щелкнув ссылку ниже.
>
> Полный список файлов с примерами можно найти в приложении.

{% file src="../datasets/5-3/3/Building Blocks of Programs - Logic.dyn" %}

### Часть I. Фильтрация списка

1. Используем логику, чтобы разделить список чисел на списки четных и нечетных чисел.

![](<../images/5-3/3/logic - exercise part I-01.jpg>)

> a. **Number Range**. Добавьте диапазон чисел в рабочую область.
>
> b. **Number**. Добавьте три узла Number в рабочую область. Каждый узел Number должен иметь следующие значения: _0.0_ для _start_, _10.0_ для _end_ и _1.0_ для _step_.
>
> c. **Выходные данные**. На выходе получается список из 11 чисел в диапазоне от 0 до 10.
>
> d. **Коэффициент (%)**. **Number Range** в качестве входных данных для _x_ и значение _2.0_ в качестве входных данных для _y_. При этом рассчитывается остаток каждого числа в списке при делении на 2. На выходе из этого списка будет представлен список чередующихся значений 0 и 1.
>
> e. **Проверка равенства (==).** Добавьте в рабочую область проверку равенства. Соедините выходные данные _коэффициента_ с входным параметром _x_, а значение _0.0_ с входных параметром _y_.
>
> f. **Watch**. В качестве выходных данных проверки равенства будет представлен список значений true или false. С помощью этих значений элементы будут разделяться в списке. _0_ (или _true_) соответствует четным числам, а _1_ (или _false_) — нечетным.
>
> g. **List.FilterByBoolMask**. Этот узел отфильтровывает значения по двум разным спискам в зависимости от вводимого логического выражения. Соедините исходный _диапазон чисел_ с входным параметром _list_, а выходной параметр _проверки равенства_ с входным параметром _mask_. В выходных данных _in_ представлены истинные значения, а в _out_ — ложные.
>
> h. **Watch**. В результате выводятся списки четных и нечетных чисел. Итак, с помощью логических операторов мы разделили списки по определенному признаку.

### Часть II. От логики к геометрии

Применим логику из первого упражнения к моделированию.

2\. За основу возьмем предыдущее упражнение с теми же узлами. Помимо изменения формата единственными исключениями будут следующие.

![](<../images/5-3/3/logic - exercise part II-01.jpg>)

> a. Используйте узел **Sequence** с этими входными значениями.
>
> b. Входной параметр list отсоединен от узла **List.FilterByBoolMask**. Эти узлы пока не нужны, но они потребуются позже.

3\. Начнем с создания отдельной группы Graph, как показано на изображении выше. Эта группа узлов представляет собой параметрическое уравнение для определения линейной кривой. Примечания.

![](<../images/5-3/3/logic - exercise part II-02.jpg>)

> a. Первый регулятор **Number Slider** представляет частоту волны в диапазоне от 1 до 4 с шагом 0,01.
>
> b. Второй регулятор **Number Slider** представляет амплитуду волны в диапазоне от 0 до 1 с шагом 0,01.
>
> c. **PolyCurve.ByPoints**. Если скопировать приведенную выше схему узлов, на видовом экране предварительного просмотра Dynamo будет создана синусоидальная кривая.

При вводе данных используйте числовые узлы для более статических свойств и регуляторы чисел для более гибких свойств. Необходимо сохранить исходный диапазон чисел, который определяется в начале этого шага. Однако синусоидальная кривая, которую мы пытаемся создать, должна обладать определенной гибкостью. Перемещая регуляторы, можно видеть частотные и амплитудные изменения кривой.

![](<../images/5-3/3/logic - exercise part II-03.gif>)

4\. Заглянем немного вперед и посмотрим на конечный результат, чтобы представить, каким он должен быть. Первые два шага выполняются отдельно, теперь их нужно соединить. С помощью базовой синусоидальной кривой будет определяться местоположение компонентов молнии, а с помощью логики «истина/ложь» — элементы меньшего или большего размера.

![](<../images/5-3/3/logic - exercise part II-04.jpg>)

> a. **Math.RemapRange**. С помощью последовательности чисел, созданной на шаге 02, сформируйте новую последовательность чисел, перенастроив диапазон. Исходные числа из шага 01 имеют диапазон от 0 до 100. С помощью входных параметров _newMin_ и _newMax_ диапазон значений изменяется на 0–1 соответственно.

5\. Создайте узел **Curve.PointAtParameter**, а затем соедините выходной параметр **Math.RemapRange** из шага 04 с входным параметром _param_.

![](<../images/5-3/3/logic - exercise part II-05.jpg>)

В этом шаге создаются точки вдоль кривой. Диапазон чисел был перенастроен на 0–1, так как входной параметр _param_ ищет значения в этом диапазоне. Значение _0_ соответствует начальной точке, а значение _1_ — конечным точкам. Все промежуточные числа относятся к диапазону _\[0,1]_.

6\. Соедините выходной параметр узла **Curve.PointAtParameter** с узлом **List.FilterByBoolMask**, чтобы разделить список четных и нечетных индексов.

![](<../images/5-3/3/logic - exercise part II-06.jpg>)

> a. **List.FilterByBoolMask**. Соедините узел **Curve.PointAtParameter** из предыдущего шага с входным параметром _list_.
>
> b. **Watch**. Узлы Watch для _in_ и _out_ показывают, что имеется два списка: четные и нечетные индексы. Тот же самый порядок точек используется в кривой, что демонстрируется в следующем шаге.

7\. Далее используйте результат вывода из узла **List.FilterByBoolMask** на шаге 05 для создания геометрий с размерами в соответствии с индексами.

**Cuboid.ByLength.** Для создания молнии вдоль синусоидальной кривой воспроизведите связи, представленные на изображении выше. В данном случае кубоид — это просто рамка, размер которой определяется в зависимости от точки кривой в центре рамки. Теперь логика четных/нечетных делений в модели должна быть понятной.

![](<../images/5-3/3/logic - exercise part II-07.jpg>)

> a. Список кубоидов с четными индексами.
>
> b. Список кубоидов с нечетными индексами.

Готово! Вы только что запрограммировали процесс определения геометрических размеров в соответствии с логической операцией, показанной в этом упражнении.
