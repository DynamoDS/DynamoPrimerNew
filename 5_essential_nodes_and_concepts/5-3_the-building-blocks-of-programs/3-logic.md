# 邏輯

藉由**邏輯**，或者更明確地說，藉由**條件邏輯**，我們可以根據測試指定單一或一組動作。在評估測試時，我們可以使用表示 `True` 或 `False` 的布林值控制程式流程。

### 布林

數值變數可以儲存所有範圍的不同數字。布林變數只能儲存兩個值，稱為 True 或 False、是或否、0 或 1。由於布林值範圍有限，因此很少使用布林值執行計算。

### 條件陳述式

「If」陳述式是程式設計中的關鍵概念：「如果 _這_ 是真的，則會發生 _那件事_，否則會發生 _其他事_。」陳述式所產生的動作由布林值驅動。在 Dynamo 中，可以採用多種方式定義「if」陳述式：

| 圖示                                         | 名稱 (語法)             | 輸入            | 輸出 |
| -------------------------------------------- | ------------------------- | ----------------- | ------- |
| ![](../images/5-1/If.jpg)                    | If (**If**)               | test、true、false | result  |
| ![](../images/5-1/Formula.jpg)               | Formula (**IF(x,y,z)**)   | x、y、z           | result  |
| ![](<../images/5-1/CodeBlock(1)(1) (1).jpg>) | Code Block (**(x?y:z);**) | x? y, z           | result  |

接下來瞭解使用條件「if」陳述式的三種有效節點中每種節點的簡單範例。

在此影像中，_boolean_ 設為 _true_，這意味著結果是字串 _「this is the result if true」_。建立 _If_ 陳述式的三個節點在這裡的工作方式完全相同。

![](../images/5-3/3/logic-conditionalstatements01false.jpg)

再說一次，節點的工作方式完全相同。若 _boolean_ 變更為 _false_，則結果是數字 _Pi_，如原始 _If_ 陳述式所定義。

![](../images/5-3/3/logic-conditionalstatements02true.jpg)

## 練習：邏輯和幾何圖形

> 按一下下方的連結下載範例檔案。
>
> 附錄中提供完整的範例檔案清單。

{% file src="../datasets/5-3/3/Building Blocks of Programs - Logic.dyn" %}

### 第 I 部分：篩選清單

1. 接下來使用邏輯將數字清單分隔為偶數清單與奇數清單。

![](../images/5-3/3/logic-exercisepartI-01.jpg)

> a.**Number Range -** 在圖元區加入一個數字範圍。
>
> b.**Numbers -** 在圖元區加入三個數字節點。每個數字節點的值應為：_0.0_ (_start_)、_10.0_ (_end_) 與 _1.0_ (_step_)。
>
> c.**輸出** \- 輸出是一個 11 個數字 (從 0 到 10) 的清單。
>
> d.**模除 (%)-** 將 **Number Range** 連接至 _x_，將 _2.0_ 連接至 _y_。這會計算清單中的每個數字除以 2 產生的餘數。此清單的輸出是 0 與 1 交替顯示的數值清單。
>
> e.**相等性測試 (==) -** 在圖元區加入相等性測試。將 _模除_ 輸出插入 _x_ 輸入，將 _0.0_ 插入 _y_ 輸入。
>
> f.**Watch -** 相等性測試的輸出是 true 與 false 交替顯示的清單。這些值用於分隔清單中的項目。_0_ (或 _true_) 表示偶數，_1_ (或 _false_) 表示奇數。
>
> g.**List.FilterByBoolMask -** 此節點將根據輸入的布林值，將這些值篩選到兩個不同清單中。將原始的 _Number Range_ 插入 _list_ 輸入，將 _相等性測試_ 輸出插入 _mask_ 輸入。輸出 _in_ 表示 true 值，而輸出 _out_ 表示 false 值。
>
> h.**Watch** \- 結果是我們現在產生了偶數清單與奇數清單。我們已使用邏輯運算子將清單分隔為多種樣式！

### 第 II 部分：從邏輯到幾何圖形

接下來我們將建置第一個練習中建立的邏輯，將此設置套用到塑型作業中。

2\.我們從上一個練習開始，採用相同的節點。唯一的例外 (除了變更格式) 是：

![](../images/5-3/3/logic-exercisepartII-01.jpg)

> a.使用 **Sequence** 節點搭配這些輸入值。
>
> b.我們取消插入 **List.FilterByBoolMask** 的 list 輸入。暫時將這些節點放在一旁，它們在稍後的練習中會有用。

3\.我們先為圖表建立不同群組，如以上影像所示。此節點群組表示定義曲線所用的參數式方程式。一些註記如下：

![](../images/5-3/3/logic-exercisepartII-02.jpg)

> a.第一個 **Number Slider** 表示波浪的頻率，最小值為 1，最大值為 4，步長為 0.01。
>
> b.第二個 **Number Slider** 表示波浪的振幅，最小值為 0，最大值為 1，步長為 0.01。
>
> c.**PolyCurve.ByPoints -** 若複製以上節點圖，在 Dynamo 預覽視埠中的結果將是一條正弦曲線。

此處採用的輸入方式：對比較靜態的性質使用數字節點，對比較彈性的性質使用數字滑棒。我們希望保留在這一步開始時定義的原始數字範圍。但是，我們在此建立的正弦曲線應具有某些彈性。我們可以移動這些滑棒以觀看曲線對其頻率與振幅的更新。

![](../images/5-3/3/logic-exercisepartII-03.gif)

4\.我們將對定義進行一些調整，因此接下來看一下最終結果，以便可以參考得到的結果。之前，前兩個步驟是分別執行的，現在我們要連接兩者。我們將使用基準正弦曲線以驅動拉鍊元件的位置，並使用 true/false 邏輯實現大小方塊的交替變化。

![](../images/5-3/3/logic-exercisepartII-04.jpg)

> a.**Math.RemapRange** \- 接下來使用步驟 02 中建立的數字序列，透過重新對映範圍建立新的數字系列。步驟 01 的原始數字介於 0-100 之間。這些數字的範圍分別由 _newMin_ 與 _newMax_ 輸入限制為從 0 到 1。

5\.建立 **Curve.PointAtParameter** 節點，然後連接步驟 04 的 **Math.RemapRange** 輸出做為其 _param_ 輸入。

![](../images/5-3/3/logic-exercisepartII-05.jpg)

此步驟將沿曲線建立點。我們將數字重新對映到從 0 至 1 的範圍，因為 _param_ 的輸入會尋找此範圍內的值。_0_ 值表示起點，_1_ 值表示終點。這當中的所有數字都會在 _[0,1]_ 範圍內運算。

6\.將 **Curve.PointAtParameter** 的輸出連接至 **List.FilterByBoolMask**，以分隔奇數和偶數索引的清單。

![](../images/5-3/3/logic-exercisepartII-06.jpg)

> a.**List.FilterByBoolMask** \- 將上一步的 **Curve.PointAtParameter** 插入 _list_ 輸入。
>
> b.**Watch -** _in_ 的 Watch 節點與 _out_ 的 Watch 節點顯示我們有兩個分別代表偶數索引與奇數索引的清單。這些點按照在曲線上的位置順序排序，我們將在下一步示範。

7\.接下來，我們將使用步驟 05 中 **List.FilterByBoolMask** 的輸出結果，根據其索引產生不同大小的幾何圖形。

**Cuboid.ByLengths -** 重新建立以上影像顯示的連接，以產生一條沿正弦曲線的拉鍊。立方體在這裡只是方塊，我們將根據方塊中心的曲線點定義其大小。現在，模型中應該已清晰呈現偶數/奇數的區分邏輯。

![](../images/5-3/3/logic-exercisepartII-07.jpg)

> a.偶數索引處的立方體清單。
>
> b.奇數索引處的立方體清單。

瞧！您剛剛根據本練習示範的邏輯作業，以程式設計了定義幾何圖形維度的過程。
