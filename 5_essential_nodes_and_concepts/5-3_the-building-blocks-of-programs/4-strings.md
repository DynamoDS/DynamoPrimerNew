# Строки

### Что такое строка

Формально **строка** — это последовательность символов, представляющих литеральную константу или переменную определенного типа. Однако на сленге программистов строкой называется любой текст. Мы уже говорили о том, как можно управлять параметрами с помощью целых и десятичных чисел. Аналогичным образом можно работать и с текстом.

### Создание строк

Строки применяются в разных ситуациях, в том числе при настройке пользовательских параметров, аннотировании документации и анализе текстовых наборов данных. Узел String находится в разделе Core > Input Category.

Примеры узлов выше являются строками. В виде строки может быть представлено число, буква или целый массив текста.

![](<../images/5-3/4/strings - creating strings.jpg>)

## Упражнение

> Скачайте файл примера, щелкнув указанную ниже ссылку.
>
> Полный список файлов примеров можно найти в приложении.

{% file src="../datasets/5-3/4/Building Blocks of Programs - Strings.dyn" %}

### Запрос строк

С помощью запроса строк можно быстро анализировать большие объемы данных. Поговорим о некоторых основных операциях, которые могут ускорить рабочий процесс и обеспечить совместимость программного обеспечения.

На следующем изображении показана строка данных из внешней электронной таблицы. Строка представляет вершины прямоугольника в плоскости XY. Рассмотрим подробнее некоторые операции по разделению строк в небольшом упражнении.

![](<../images/5-3/4/strings - querying strings 01.jpg>)

> 1. В качестве разделителя вершин прямоугольника используется точка с запятой «;». При этом создается список, содержащий 3 элемента для каждой вершины.

![](<../images/5-3/4/strings - querying strings 02.jpg>)

> 1. Если нажать знак «_+_» посредине узла, будет создан новый разделитель.
> 2. Добавьте строку «_,_» в рабочую область и соедините ее с новым входным параметром separator.
> 3. Получится список из десяти элементов. Сначала в качестве разделителя узла используется значение _separator0_, а затем — _separator1_.

Хотя элементы списка на изображении выше выглядят как числа, в Dynamo они все так же считаются отдельными строками. Для создания точек тип соответствующих данных необходимо преобразовать из строкового в числовой. Для этого используется узел **String.ToNumber**.

![](<../images/5-3/4/strings - querying strings 03.jpg>)

> 1. Этот узел достаточно прост. Соедините результаты **String.Split** с входным параметром. Кажется, что выходные данные не изменились, но теперь типом данных будет _number_, а не _string_.

Добавив несколько дополнительных операций, вы создали треугольник на основе исходных строковых входных данных в начале координат.

![](<../images/5-3/4/strings - querying strings 04.jpg>)

### Операции со строками

Так как строка является типовым текстовым объектом, у нее есть множество применений. Рассмотрим основные действия в разделе Core > String Category в Dynamo.

На изображении представлен метод объединения двух строк по порядку. Берется каждая литеральная строка в списке и создается одна объединенная строка.

На следующем изображении показана операция объединения трех строк.

![Concatenate](<../images/5-3/4/strings - manipulating strings 01.jpg>)

> 1. Нажатием кнопок «+/-» в центре узла можно добавлять или удалять строки.
> 2. На выходе получается одна объединенная строка с пробелами и знаками препинания.

Метод соединения очень похож на метод объединения, но в нем есть дополнительный слой пунктуации.

Пользователям, работающим с Excel, могут быть знакомы файлы CSV. CSV расшифровывается как comma-separated values — значения, разделенные запятыми. Чтобы создать данные с аналогичной структурой, в узле **String.Join** в качестве разделителя можно использовать запятую (или в данном случае два дефиса).

На следующем изображении показано соединение двух строк.

![](<../images/5-3/4/strings - manipulating strings 02.jpg>)

> 1. Входной параметр separator позволяет создать строку, выступающую в качестве разделителя соединенных строк.

### Работа со строками

В этом упражнении с помощью методов запроса строк и операций со строками мы разберем последнее четверостишие стихотворения американского поэта Роберта Фроста [Stopping By Woods on a Snowy Evening](http://www.poetryfoundation.org/poem/171621). Хотя это не самый практичный пример, он поможет понять, как выполнять основные операции со строками в связном тексте с размером и рифмой.

Начнем с разделения строк четверостишия. Прежде всего, обратим внимание на то, что в стихотворении используются запятые. С помощью них можно будет разделить каждую строчку на отдельные элементы.

![](<../images/5-3/4/strings - working with strings 01.jpg>)

> 1. Исходная строка вставляется в узел **String**.
> 2. Для указания разделителя используется еще один узел **String**. В данном случае разделителем будет запятая.
> 3. В рабочую область добавляется узел **String.Split**, который соединяется с двумя строками.
> 4. На выходе строчки разделены на отдельные элементы.

Перейдем к самой интересной части стихотворения: последним двум строчкам. Исходное четверостишие представляло собой один элемент данных. Сперва эти данные были разделены на отдельные элементы. Теперь необходимо найти нужный нам текст. Хотя это _можно_ осуществить, выбрав два последних элемента списка, в случае с целой книгой не обязательно прочитывать ее всю и выделять элементы вручную.

![](<../images/5-3/4/strings - working with strings 02.jpg>)

> 1. Вместо того чтобы выполнять поиск вручную, используйте узел **String.Contains** для поиска набора символов. Этот узел аналогичен команде «Найти» в текстовом редакторе. В этом случае при обнаружении подстроки в элементе возвращается значение «Истина» или «Ложь».
> 2. Для входного параметра _searchFor_ определите подстроку, которую необходимо найти в четверостишии. Воспользуйтесь узлом **String** с текстом «And miles».
> 3. На выходе получим список значений «Истина» и «Ложь». Воспользуемся этой логикой для фильтрации элементов на следующем этапе.

![Split](<../images/5-3/4/strings - working with strings 03.jpg>)

> 1. Для отбора значений True и False используйте узел **List.FilterByBoolMask**. Выходной параметр in возвращает выражения с входным значением mask, для которых действительно значение «Истина», а выходной параметр out — выражения, для которых действительно значение «Ложь».
> 2. Результат на выходном параметре in соответствует ожиданиям, то есть мы получаем две последние строки четверостишия.

Теперь необходимо воссоздать повтор, объединив две строки вместе. Если посмотреть на результаты выполнения предыдущего шага, можно заметить, что в списке присутствуют два элемента.

![](<../images/5-3/4/strings - working with strings 04.jpg>)

> 1. С помощью двух узлов **List.GetItemAtIndex** можно изолировать элементы, используя значения 0 и 1 в качестве входных данных индекса.
> 2. На выходе из каждого узла получаем последние две строки, расположенные по порядку.

Для объединения этих двух элементов в один используйте узел **String.Join**.

![Split String](<../images/5-3/4/strings - working with strings 05.jpg>)

> 1. После добавления узла **String.Join** становится понятно, что требуется разделитель.
> 2. Для создания разделителя добавьте узел **String** в рабочую область и введите запятую.
> 3. Конечный результат — объединение двух последних элементов в один.

Изолирование двух последних строк может показаться довольно трудоемким процессом. Это действительно так — операции со строками часто требуют предварительной подготовки. Однако эти операции масштабируемы и могут сравнительно легко применяться к большим наборам данных. Если работа с электронными таблицами и настройка совместимости осуществляются на параметрической основе, обязательно помните об операциях со строками.
